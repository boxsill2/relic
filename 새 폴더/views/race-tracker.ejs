<!DOCTYPE html>
<html lang="ko">
<head>
    <meta charset="UTF-8">
    <title>Race Replay - <%= session_key %></title>
    <meta name="viewport" content="width=device-width,initial-scale=1">
    <link rel="stylesheet" href="/css/base.css?v=f1">
    <link rel="stylesheet" href="/css/header-style.css?v=f1">
    <link rel="stylesheet" href="/css/race-tracker-style.css?v=f1">
    <style>
      .replay-layout {
        /* 우측 리더보드 제거 → 한 칼럼 */
        display: grid;
        grid-template-columns: 1fr;
        gap: 20px;
        align-items: flex-start;
      }
      #track-container {
        position: relative;
        width: 100%;
        aspect-ratio: 16/9;
        background-color: #181820;
        border-radius: 12px;
        overflow: hidden;
      }
      #trackCanvas {
        position: absolute;
        top: 0;
        left: 0;
        width: 100%;
        height: 100%;
      }
      @media (max-width: 900px) {
        .replay-layout { grid-template-columns: 1fr; }
        #track-container { aspect-ratio: 1/1; }
      }

      #track-message-overlay {
        position: absolute;
        top: 50%; left: 50%; transform: translate(-50%, -50%);
        padding: 20px; text-align: center; background: rgba(0,0,0,0.8);
        border-radius: 12px; display: none; z-index: 10;
        max-width: 80%;
      }
    </style>
</head>
<body>
<%- include('partials/header', { currentPage: 'schedule' }) %>
<main class="container">
    <div class="title-header"><h1>Race Replay: <%= sessionInfo?.meeting_name || sessionInfo?.country_name || session_key %></h1></div>
    
    <div class="replay-layout">
        <div id="track-container">
            <canvas id="trackCanvas"></canvas>
            <div id="track-message-overlay"></div>
        </div>
        <!-- 우측 리더보드 전체 제거 -->
    </div>
    
    <div class="timeline-controls">
        <button id="playPauseBtn" class="play-pause-btn">▶</button>
        <span id="currentTime" class="timeline-time">00:00:00</span>
        <input type="range" id="timelineSlider" class="timeline-slider" min="0" value="0">
        <span id="totalTime" class="timeline-time">00:00:00</span>
    </div>
</main>

<script id="__session_info" type="application/json"><%- JSON.stringify(sessionInfo || null) %></script>
<script id="__driver_directory" type="application/json"><%- JSON.stringify(driverDirectory || {}) %></script>

<script>
    const SESSION_INFO = JSON.parse(document.getElementById('__session_info').textContent);
    const DRIVER_DIRECTORY = JSON.parse(document.getElementById('__driver_directory').textContent);
    const canvas = document.getElementById('trackCanvas'), ctx = canvas.getContext('2d');
    const timelineSlider = document.getElementById('timelineSlider'), currentTimeEl = document.getElementById('currentTime'), totalTimeEl = document.getElementById('totalTime');
    const playPauseBtn = document.getElementById('playPauseBtn'), messageOverlay = document.getElementById('track-message-overlay');
    const trackContainer = document.getElementById('track-container');
    
    const PADDING = 40;
    const raceDuration = 7200000;          // 세션 전체 길이(추정 2h)
    const CHUNK_DURATION_MS = 120000;
    const LAP_ESTIMATE_MS = 180000;        // 1랩(3분)만 미리 로드해 레이아웃/스타트 검사
    // 필요하면 240000으로 늘려 초기 창을 4분으로 확장 가능

    // ★ 레이스 스타트 보정(formation lap 스킵)
    let RACE_START_OFFSET_MS = 0;

    // race_control에서 "Race Start/Lights Out" 우선, 없으면 세션 시작 후 5분 이내의 첫 GREEN만 인정
    function detectRaceStartOffset(raceControl) {
      if (!Array.isArray(raceControl) || !SESSION_INFO?.date_start) return 0;
      const t0 = new Date(SESSION_INFO.date_start).getTime();

      const norm = v => String(v || '').toLowerCase();
      const events = raceControl
        .map(m => ({ ...m, ts: new Date(m.date).getTime(), msg: norm(m.message), flag: String(m.flag || '').toUpperCase() }))
        .filter(m => !Number.isNaN(m.ts))
        .sort((a, b) => a.ts - b.ts);

      // (A) 명시 메시지 우선
      const explicit = events.find(m => /race\s*start|lights?\s*out/.test(m.msg));
      if (explicit) return Math.max(0, explicit.ts - t0);

      // (B) 세션 시작 + 5분 창 안의 첫 GREEN만
      const GREEN_WINDOW_MS = 5 * 60 * 1000;
      const green = events.find(m => {
        const isGreen = m.flag === 'GREEN' || /green\s*flag/.test(m.msg);
        const within = m.ts >= t0 && (m.ts - t0) <= GREEN_WINDOW_MS;
        const isSC = /safety\s*car|virtual\s*safety\s*car|\bsc\b|\bvsc\b/.test(m.msg);
        return isGreen && within && !isSC;
      });
      if (green) return Math.max(0, green.ts - t0);

      // (C) 실패 시 보정하지 않음
      return 0;
    }
    
    let bbox = null; 
    let playbackState = {
        isPlaying: false, currentTimeMs: 0, lastSystemTime: 0,
        isBuffering: false, bufferedUntilMs: 0,
        locationBuffer: [] // 리더보드용 positionBuffer 제거
    };
    const trackPath = new Map();
    
    let orientationCalculated = false;
    let initialAngle = 0;
    let flipX = 1;

    const msToTime = ms => {
      const h=String(Math.floor(ms/3600000)).padStart(2,'0'),
            m=String(Math.floor((ms%3600000)/60000)).padStart(2,'0'),
            s=String(Math.floor((ms%60000)/1000)).padStart(2,'0');
      return `${h}:${m}:${s}`;
    };
    const showMessage = (text) => { messageOverlay.textContent = text; messageOverlay.style.display = 'block'; };
    const hideMessage = () => { messageOverlay.style.display = 'none'; };
    const rotatePoint = (x, y, angle) => ({
        x: x * Math.cos(angle) - y * Math.sin(angle),
        y: x * Math.sin(angle) + y * Math.cos(angle)
    });

    function calculateOrientationAndBbox(locations) {
        if (!locations || locations.length < 2) return;

        // 1) 주행 방향(시계/반시계) 추정
        const driverNumbers = [...new Set(locations.map(p => p.driver_number))];
        if (driverNumbers.length > 0) {
            const path = locations.filter(p => p.driver_number === driverNumbers[0]);
            if (path.length > 50) {
                const p1 = path[0], p2 = path[25], p3 = path[50];
                const cross = (p2.x - p1.x) * (p3.y - p2.y) - (p2.y - p1.y) * (p3.x - p2.x);
                if (cross > 0) flipX = -1;
            }
        }
        // 2) 진행 방향을 오른쪽으로 정렬
        const firstPoint = locations[0];
        const secondPoint = locations.find(p => p.x !== firstPoint.x || p.y !== firstPoint.y);
        if (firstPoint && secondPoint) {
            const dx = (secondPoint.x - firstPoint.x) * flipX;
            const dy = secondPoint.y - firstPoint.y;
            initialAngle = -Math.atan2(dy, dx);
        }

        // 3) 변환 후 BBox 계산
        const tempBbox = { minX: Infinity, maxX: -Infinity, minY: Infinity, maxY: -Infinity };
        locations.forEach(loc => {
            const flippedX = loc.x * flipX;
            const rotated = rotatePoint(flippedX, loc.y, initialAngle);
            tempBbox.minX = Math.min(tempBbox.minX, rotated.x);
            tempBbox.maxX = Math.max(tempBbox.maxX, rotated.x);
            tempBbox.minY = Math.min(tempBbox.minY, rotated.y);
            tempBbox.maxY = Math.max(tempBbox.maxY, rotated.y);
        });
        bbox = tempBbox;
        orientationCalculated = true;

        // 4) 트랙 비율에 맞춰 컨테이너 비율 보정(옵션)
        const trackWidth = bbox.maxX - bbox.minX;
        const trackHeight = bbox.maxY - bbox.minY;
        if (trackHeight > 0 && window.innerWidth > 900) {
            trackContainer.style.setProperty('--track-aspect-ratio', trackWidth / trackHeight);
        }
    }

    async function togglePlayPause() {
        if (playbackState.isPlaying) {
            playbackState.isPlaying = false;
            playPauseBtn.textContent = '▶';
            return;
        }
        playbackState.isPlaying = true;
        playPauseBtn.textContent = '❚❚';
        playbackState.lastSystemTime = performance.now();
        requestAnimationFrame(gameLoop);
    }
    
    function gameLoop(now) {
        if (!playbackState.isPlaying) return;
        if (!playbackState.lastSystemTime) playbackState.lastSystemTime = now;
        const deltaTime = now - playbackState.lastSystemTime;
        playbackState.lastSystemTime = now;
        playbackState.currentTimeMs += deltaTime;
        if (playbackState.currentTimeMs >= raceDuration) {
            playbackState.currentTimeMs = raceDuration;
            togglePlayPause();
        }
        updateUI(playbackState.currentTimeMs);
        if (playbackState.isPlaying) requestAnimationFrame(gameLoop);
    }
    
    function updateUI(timeMs) {
        // 표시(슬라이더/시간)는 레이스 스타트 기준 0부터
        const displayMs = Math.max(0, timeMs - RACE_START_OFFSET_MS);
        timelineSlider.value = displayMs;
        currentTimeEl.textContent = msToTime(displayMs);
        drawOnCanvas(); // 리더보드 없음
    }
    
    function drawOnCanvas() {
        if (!canvas.parentElement) return;
        canvas.width = canvas.parentElement.clientWidth;
        canvas.height = canvas.parentElement.clientHeight;

        ctx.clearRect(0, 0, canvas.width, canvas.height);
        ctx.fillStyle = '#181820';
        ctx.fillRect(0, 0, canvas.width, canvas.height);
        
        if (!SESSION_INFO?.date_start || !bbox || !orientationCalculated) return;
        
        const showDrivers = playbackState.isPlaying || playbackState.currentTimeMs > 0;
        // 실제 타깃 시간 = 세션 시작 + currentTime(절대) 
        const targetTime = new Date(new Date(SESSION_INFO.date_start).getTime() + playbackState.currentTimeMs);
        
        // 스케일/오프셋 계산
        const trackWidth = bbox.maxX - bbox.minX;
        const trackHeight = bbox.maxY - bbox.minY;
        const canvasDrawableWidth = canvas.width - (PADDING * 2);
        const canvasDrawableHeight = canvas.height - (PADDING * 2);
        const scaleX = trackWidth > 0 ? canvasDrawableWidth / trackWidth : 1;
        const scaleY = trackHeight > 0 ? canvasDrawableHeight / trackHeight : 1;
        const scale = Math.min(scaleX, scaleY);

        const trackCenterX = (bbox.minX + bbox.maxX) / 2;
        const trackCenterY = (bbox.minY + bbox.maxY) / 2;
        const offsetX = (canvas.width / 2) - (trackCenterX * scale);
        const offsetY = (canvas.height / 2) + (trackCenterY * scale);

        const transform = (x, y) => {
            const flippedX = x * flipX;
            const rotated = rotatePoint(flippedX, y, initialAngle);
            return { x: rotated.x * scale + offsetX, y: -rotated.y * scale + offsetY };
        };

        // 트랙 라인
        ctx.strokeStyle = 'rgba(255, 255, 255, 0.6)';
        ctx.lineWidth = 5;
        trackPath.forEach((path) => {
            if (path.length > 1) {
                ctx.beginPath();
                const startPoint = transform(path[0].x, path[0].y);
                ctx.moveTo(startPoint.x, startPoint.y);
                path.slice(1).forEach(p => {
                    const { x, y } = transform(p.x, p.y);
                    ctx.lineTo(x, y);
                });
                ctx.stroke();
            }
        });
        
        // 차량
        if (showDrivers) {
            const latestLocations = {};
            for (let i = playbackState.locationBuffer.length - 1; i >= 0; i--) {
                const loc = playbackState.locationBuffer[i];
                if (new Date(loc.date) > targetTime) continue;
                if (!latestLocations[loc.driver_number]) latestLocations[loc.driver_number] = loc;
            }
            for (const driverNumber in latestLocations) {
                const pos = latestLocations[driverNumber];
                const driverInfo = DRIVER_DIRECTORY[driverNumber] || {};
                const { x: cx, y: cy } = transform(pos.x, pos.y);
                const r = 11;

                ctx.beginPath();
                ctx.arc(cx, cy, r, 0, Math.PI * 2);
                ctx.fillStyle = driverInfo.team_colour || '#FFFFFF';
                ctx.fill();
                ctx.strokeStyle = 'rgba(0, 0, 0, 0.7)';
                ctx.lineWidth = 1.5;
                ctx.stroke();

                ctx.font = 'bold 10px Arial';
                ctx.textAlign = 'center';
                ctx.textBaseline = 'middle';
                ctx.strokeStyle = 'black';
                ctx.lineWidth = 2;
                ctx.strokeText(driverNumber, cx, cy);
                ctx.fillStyle = 'white';
                ctx.fillText(driverNumber, cx, cy);
            }
        }
    }

    async function initialize() {
        if (!SESSION_INFO) return showMessage("세션 정보를 불러올 수 없습니다.");
        
        // 초기엔 전체 길이를 표시(오프셋 계산 후 다시 보정)
        timelineSlider.max = raceDuration;
        totalTimeEl.textContent = msToTime(raceDuration);
        playPauseBtn.addEventListener('click', togglePlayPause);
        playPauseBtn.disabled = true;
        timelineSlider.disabled = true;

        // 슬라이더로 시킹 가능 (표시값 + 오프셋 = 절대 시간)
        timelineSlider.addEventListener('input', () => {
          playbackState.currentTimeMs = RACE_START_OFFSET_MS + Number(timelineSlider.value);
          updateUI(playbackState.currentTimeMs);
        });
        
        window.addEventListener('resize', resizeCanvas);
        
        let firstLapLocations = [];
        let bufferedUntilMs = 0;
        let success = true;

        // 1랩 데이터만 먼저 로드 + race_control에서 스타트 오프셋 탐색
        showMessage('트랙 레이아웃 분석 중...');
        while (bufferedUntilMs < LAP_ESTIMATE_MS && success) {
            const startTime = new Date(SESSION_INFO.date_start);
            const chunkStartMs = bufferedUntilMs;
            const chunkEndMs = Math.min(chunkStartMs + CHUNK_DURATION_MS, LAP_ESTIMATE_MS);
            const chunkStartTime = new Date(startTime.getTime() + chunkStartMs).toISOString();
            const chunkEndTime = new Date(startTime.getTime() + chunkEndMs).toISOString();

            try {
                const res = await fetch(`/api/locations/<%= session_key %>/${chunkStartTime}/${chunkEndTime}`);
                const data = await res.json();
                if (data.error) throw new Error(data.error);

                if (bufferedUntilMs === 0 && (!data.locations || data.locations.length === 0)) {
                    throw new Error("이 경기에 대한 주행 데이터가 없습니다.");
                }

                if (data.locations) firstLapLocations.push(...data.locations);
                // formation lap 스킵: race_control로 레이스 스타트 시각 찾기(최초 청크에서 발견되면 바로 기록)
                if (Array.isArray(data.race_control) && RACE_START_OFFSET_MS === 0) {
                  const off = detectRaceStartOffset(data.race_control);
                  if (off > 0) {
                    console.debug('[RaceStartOffset]', off, 'ms');
                    RACE_START_OFFSET_MS = off;
                  }
                }

                bufferedUntilMs = chunkEndMs;
            } catch (error) {
                console.error('데이터 로딩 실패:', error);
                showMessage(error.message.includes('주행 데이터') ? error.message : `오류가 발생했습니다: ${error.message}`);
                success = false;
            }
        }
        
        if (success) {
            hideMessage();
            playbackState.locationBuffer = firstLapLocations;
            
            // 트랙 궤적 생성
            firstLapLocations.forEach(loc => {
                const dn = loc.driver_number;
                if (!trackPath.has(dn)) trackPath.set(dn, []);
                trackPath.get(dn).push({ x: loc.x, y: loc.y });
            });

            calculateOrientationAndBbox(firstLapLocations);
            
            // ▶ 포메이션 랩 스킵: 시작 시간을 레이스 스타트로 이동
            playbackState.currentTimeMs = Math.max(playbackState.currentTimeMs, RACE_START_OFFSET_MS);
            // 표시/슬라이더 범위도 스타트 기준으로 재설정
            timelineSlider.max = Math.max(0, raceDuration - RACE_START_OFFSET_MS);
            timelineSlider.value = 0; // 화면상 0 = 레이스 스타트
            currentTimeEl.textContent = msToTime(0);
            totalTimeEl.textContent = msToTime(Number(timelineSlider.max));

            playPauseBtn.disabled = false;
            timelineSlider.disabled = false;
            
            resizeCanvas();
        }
    }

    function resizeCanvas() { 
        if (trackContainer) {
            canvas.width = trackContainer.clientWidth;
            canvas.height = trackContainer.clientHeight;
            drawOnCanvas(); 
        }
    }
    
    initialize();
</script>
</body>
</html>
